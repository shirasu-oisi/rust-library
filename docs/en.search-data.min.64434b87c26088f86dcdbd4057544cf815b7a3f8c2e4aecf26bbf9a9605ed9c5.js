'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/library/docs/exhaustive_search/next_permutation/','title':"Test",'section':"Docs",'content':"next_permutation #  概要 #  与えられた拝謁の、次の順列を生成します。はじめにソートされている必要があります。\n使用例 #  fn main() { let mut x = vec![3.14, -1.25, 4.4]; x.sort_by(|a, b| a.partial_cmp(b).unwrap()); assert_eq!(x, vec![-1.25, 3.14, 4.4]); while { println!(\u0026#34;{:?}\u0026#34;, x); next_permutation(\u0026amp;mut x) } {} } output: [-1.25, 3.14, 4.4] [-1.25, 4.4, 3.14] [3.14, -1.25, 4.4] [3.14, 4.4, -1.25] [4.4, -1.25, 3.14] [4.4, 3.14, -1.25] 実装 #  fn next_permutation\u0026lt;T: PartialOrd\u0026gt;(v: \u0026amp;mut [T]) -\u0026gt; bool { let mut i: i64 = -1; let mut j: usize = 0; for (idx, e) in v.iter().enumerate() { if idx == v.len() - 1 { break; } if *e \u0026lt; v[idx + 1] { i = idx as i64; } } if i == -1 { return false; }; let i = i as usize; for (idx, e) in v.iter().enumerate().rev() { if *e \u0026gt; v[i] { j = idx; break; } } v.swap(i, j); v[i + 1..].reverse(); true } "});})();